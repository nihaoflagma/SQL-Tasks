SQL-Tasks
В этом проекте представлены решения различных SQL-задач, которые охватывают основы работы с базами данных, включая создание таблиц, их наполнение и манипуляцию данными. Задания были решены с использованием языка SQL и охватывают четыре основные базы данных: транспортные средства, автомобильные гонки, бронирование отелей и структура организации.

В процессе работы были решены 13 задач, каждая из которых направлена на улучшение навыков работы с SQL. Примеры запросов включают фильтрацию, сортировку, агрегацию, использование объединений (UNION), подзапросов и рекурсивных запросов.

Базы данных
Мы использовали следующие базы данных для выполнения задач:

Транспортные средства — данные о различных транспортных средствах (автомобили, мотоциклы, велосипеды).

Автомобильные гонки — информация о гонках, автомобилях и их результатах.

Бронирование отелей — данные о бронированиях, клиентах и отелях.

Структура организации — данные о сотрудниках, менеджерах, проектах и задачах.

Каждая из этих баз данных сопровождается скриптами для создания и заполнения таблиц тестовыми данными, что позволяет ускорить решение задач.

ИНСТРУКЦИЯ ПО ЗАПУСКУ:
1. Установка PostgreSQL
Скачай и установи PostgreSQL:
Перейди на официальный сайт PostgreSQL.
Выбери версию для своей операционной системы (Windows, macOS, Linux).
Следуй инструкциям по установке на сайте.
Установка pgAdmin:
При установке PostgreSQL, ты можешь установить также и pgAdmin — это графический интерфейс для работы с PostgreSQL.

2. Подключение к базе данных через pgAdmin
Открой pgAdmin:
Запусти pgAdmin, который устанавливался вместе с PostgreSQL.
Создание нового подключения:
В pgAdmin в левом меню кликни на Servers (или правой кнопкой мыши и выбери Create > Server).
В появившемся окне укажи настройки:
Name: Укажи любое имя для подключения.
Host: localhost (если база данных находится на локальной машине).
Port: 5432 (по умолчанию).
Maintenance Database: postgres (база данных по умолчанию).
Username: postgres (если ты не менял учетные данные).
Password: Введи пароль, который установил при настройке PostgreSQL.
Нажми Save.
Подключение к серверу:
После создания подключения, кликни на подключенный сервер в списке и разверни его.
Откроется список баз данных. Найди свою базу данных (если ты её создавал, она должна быть там).

3. Создание базы данных (если необходимо)
Если ты не создал свою базу данных, следуй этим шагам:
В pgAdmin кликни правой кнопкой на Databases и выбери Create > Database.
Укажи название базы данных (например, my_database), оставь все остальные параметры по умолчанию и нажми Save.

4. Вставка данных и выполнение SQL-запросов
Открой SQL-терминал:
Выбери нужную базу данных в pgAdmin
В меню сверху нажми Tools > Query Tool для открытия SQL-терминала.
Загрузка структуры базы данных:
В SQL-терминале нажми File > Open и выбери файл с запросом на создание таблиц (например, create_tables.sql).
Нажми Execute или F5, чтобы выполнить запрос и создать структуру базы данных.
Заполнение базы данных данными:
Открой файл с данными (например, insert_data.sql) в SQL-терминале.
Нажми Execute или F5, чтобы заполнить таблицы данными.

5. Запуск SQL-запросов для решения задач
Открой файлы с решениями задач (например, task_1.sql, task_2.sql, task_3.sql).
Нажми Execute или F5, чтобы выполнить запрос и получить результат.

6. Тестирование запросов
Проверь результаты запросов:
После выполнения SQL-запросов, ты увидишь результаты в нижней части окна pgAdmin.
Убедись, что данные, которые ты ожидал, присутствуют в таблицах и соответствуют условию задачи.
Проверь корректность запросов:
Для каждого запроса проверь, что он возвращает правильную информацию. Например:
Для задачи о подчиненных — проверь, что каждый сотрудник, занявший роль "менеджер", правильно отображает количество подчиненных.
Для задачи с проектами и задачами — убедись, что все проекты и задачи отображаются корректно для каждого сотрудника.

7. Резервное копирование и восстановление базы данных
Если ты хочешь сделать резервную копию базы данных:
В pgAdmin выбери нужную базу данных.
Кликни правой кнопкой на базе данных и выбери Backup.
Укажи путь для сохранения файла резервной копии и выбери формат (обычно используем Custom).
Нажми Backup.
Для восстановления из резервной копии:
В pgAdmin кликни правой кнопкой на Databases и выбери Restore.
Укажи путь к файлу резервной копии и нажми Restore.

8. Проверка базы данных в командной строке
Открой cmd (или PowerShell) на своем компьютере.
Перейди в папку с установленным PostgreSQL, например:
bash
Копировать
Редактировать
cd "C:\Program Files\PostgreSQL\17\bin"
Для подключения к базе данных через командную строку используй команду:
bash
Копировать
Редактировать
psql -U postgres -d my_database
Здесь:

-U — это имя пользователя (обычно postgres).

-d — имя базы данных (например, my_database).

После подключения ты можешь выполнять SQL-запросы напрямую из командной строки.

9. Тестирование запросов через командную строку
Для тестирования запросов в командной строке:
После подключения к базе данных в командной строке, можно выполнить SQL-запросы, например:
sql
Копировать
Редактировать
SELECT * FROM Employees;
Для выполнения запросов из файла используйте команду:
bash
Копировать
Редактировать
psql -U postgres -d my_database -f "C:\path\to\your\file.sql"

Структура заданий
Задание 1
Функции:

Фильтрация данных: отбор мотоциклов по мощности, стоимости и типу.

Сортировка: результаты сортируются по мощности мотоциклов в убывающем порядке.

Структура запроса:

Фильтрация данных с использованием WHERE.

Сортировка с использованием ORDER BY.

Задание 2
Функции:

Фильтрация данных по нескольким критериям для автомобилей, мотоциклов и велосипедов.

Использование UNION для объединения данных из разных категорий транспортных средств.

Сортировка результатов по мощности с учетом велосипедов (с мощностью NULL).

Структура запроса:

Фильтрация для каждого типа транспортного средства.

Объединение данных с помощью UNION ALL.

Сортировка с использованием ORDER BY.

Задание 3
Функции:

Группировка по классу автомобилей и вычисление средней позиции с использованием агрегатной функции AVG.

Фильтрация автомобилей с минимальной средней позицией.

Сортировка результатов по средней позиции в порядке возрастания.

Структура запроса:

Группировка по классам автомобилей.

Использование HAVING для фильтрации по минимальной средней позиции.

Задание 4
Функции:

Вычисление средней позиции для каждого автомобиля.

Поиск автомобиля с наименьшей средней позицией среди всех.

Если несколько автомобилей имеют одинаковую минимальную позицию, выбор по алфавиту.

Структура запроса:

Извлечение данных о всех автомобилях и вычисление их средней позиции.

Использование MIN для нахождения минимальной средней позиции.

Задание 5
Функции, реализуемые в задаче:

Вычисление средней позиции для каждого класса автомобилей: для каждого класса автомобилей необходимо вычислить среднюю позицию с использованием агрегатной функции AVG.

Поиск классов с наименьшей средней позицией: нужно найти классы с наименьшей средней позицией среди всех классов с использованием агрегатной функции MIN.

Поиск автомобилей в этих классах: для каждого класса с минимальной средней позицией необходимо найти автомобили и вывести информацию о каждом:

Имя автомобиля.

Средняя позиция автомобиля.

Количество гонок, в которых автомобиль участвовал.

Страна производства класса автомобиля.

Вывод общего количества гонок для выбранных классов: для всех автомобилей, принадлежащих классам с наименьшей средней позицией, подсчитать общее количество гонок с использованием функции COUNT.

Обработка одинаковых минимальных позиций: если несколько классов имеют одинаковую минимальную позицию, нужно отобразить все эти классы.

Структура запроса:

Извлечь данные о всех автомобилях, вычислить среднюю позицию для каждого класса.

Использовать агрегатную функцию MIN для нахождения минимальной средней позиции.

Вывести информацию о каждом автомобиле в этих классах.

Посчитать количество гонок для автомобилей, относящихся к выбранным классам.

Отобразить все классы с одинаковыми минимальными позициями.

Задание 6
Функции, реализуемые в задаче:

Вычисление средней позиции автомобилей по классу: для каждого класса автомобилей необходимо вычислить среднюю позицию с помощью функции AVG.

Выбор автомобилей с лучшей средней позицией: нужно выбрать автомобили с средней позицией ниже средней по классу. Это реализуется с использованием подзапроса для получения средней позиции для каждого класса и сравнения с позициями автомобилей.

Фильтрация классов с минимум двумя автомобилями: исключаются классы, в которых участвует только один автомобиль.

Вывод информации об автомобилях: для выбранных автомобилей из классов с более чем одним автомобилем вывести:

Имя автомобиля.

Класс автомобиля.

Среднюю позицию автомобиля.

Количество гонок, в которых участвовал автомобиль.

Страну производства класса автомобиля.

Сортировка: результат сортируется по классу, затем по средней позиции в порядке возрастания.

Структура запроса:

Вычисление средней позиции по классу для каждого автомобиля.

Фильтрация автомобилей с лучшими позициями, которые меньше средней по классу.

Группировка автомобилей по классам, исключение классов с одним автомобилем.

Вывод информации о каждом выбранном автомобиле.

Сортировка по классу и средней позиции.

Задание 7
Функции, реализуемые в задаче:

Вычисление средней позиции автомобилей: для каждого автомобиля вычисляется его средняя позиция с использованием функции AVG.

Определение автомобилей с низкой средней позицией: фильтрация автомобилей с позицией больше 3.0.

Группировка автомобилей по классу: автомобили с низкой средней позицией группируются по классу, чтобы выявить классы с наибольшим количеством таких автомобилей.

Подсчет количества автомобилей с низкой средней позицией для каждого класса: для каждого класса считается количество автомобилей, у которых средняя позиция больше 3.0.

Общее количество гонок для каждого класса: подсчитывается общее количество гонок, в которых участвовали автомобили данного класса.

Вывод информации: для каждого автомобиля из классов с наибольшим количеством автомобилей с низкой средней позицией выводится:

Имя автомобиля.

Класс автомобиля.

Среднюю позицию.

Количество гонок.

Страну производства класса.

Общее количество гонок для класса.

Сортировка: результат сортируется по количеству автомобилей с низкой средней позицией в порядке убывания.

Структура запроса:

Для каждого автомобиля вычисляется его средняя позиция.

Фильтрация автомобилей с позицией больше 3.0.

Группировка автомобилей по классам.

Подсчет общего числа гонок для каждого класса.

Вывод информации об автомобиле и классе.

Сортировка по количеству автомобилей с низкой средней позицией.

Задание 8
Функции, реализуемые в задаче:

Группировка по клиентам: необходимо сгруппировать все бронирования по каждому клиенту, чтобы подсчитать количество бронирований.

Подсчет количества бронирований: для каждого клиента подсчитывается, сколько раз он бронировал номера, с условием, что количество бронирований должно быть больше двух.

Фильтрация по количеству бронирований: отбираются только те клиенты, у которых количество бронирований больше двух и которые бронировали номера в разных отелях.

Вывод списка отелей: для каждого клиента выводится список отелей, в которых он бронировал номера. Для этого используется функция GROUP_CONCAT для объединения всех названий отелей в одну строку через запятую.

Подсчет средней длительности пребывания: для каждого клиента вычисляется средняя длительность пребывания по всем его бронированиям с помощью функции AVG.

Сортировка результатов: результаты должны быть отсортированы по количеству бронирований в порядке убывания.

Описание SQL-запроса:

Группировка бронирований по клиенту: данные бронирований группируются по ClientID.

Подсчет количества бронирований и фильтрация: используется условие "больше двух бронирований" для каждого клиента.

Вывод списка отелей: с помощью функции GROUP_CONCAT объединяются все названия отелей для каждого клиента.

Подсчет средней длительности пребывания: используется функция AVG для вычисления средней длительности пребывания.

Сортировка результатов: сортировка выполняется по количеству бронирований в порядке убывания.

Задание 9
Функции, реализуемые в задаче:

Группировка данных по клиентам: нужно сгруппировать все бронирования по каждому клиенту.

Подсчет количества бронирований и уникальных отелей: для каждого клиента подсчитывается количество бронирований и уникальных отелей, в которых они забронировали номера.

Фильтрация клиентов по количеству бронирований: отбираются клиенты, которые сделали более двух бронирований и забронировали номера в разных отелях.

Подсчет общей потраченной суммы: для каждого клиента вычисляется общая сумма, потраченная на бронирования.

Фильтрация по сумме потраченных денег: отбираются только те клиенты, которые потратили более 500 долларов.

Объединение данных: объединяются клиенты, которые удовлетворяют обоим условиям.

Сортировка по общей сумме: результаты сортируются по общей сумме, потраченной клиентами, в порядке возрастания.

Описание SQL-запроса:

Группировка по клиенту: работа с таблицами Clients, Reservations, и Hotels для подсчета бронирований и уникальных отелей.

Подсчет бронирований и уникальных отелей: используется условие на количество бронирований и уникальных отелей для каждого клиента.

Фильтрация по количеству и сумме: клиенты, которые забронировали более двух отелей и потратили больше 500 долларов, отбираются с помощью условий.

Объединение данных: объединение информации из нескольких запросов.

Сортировка по сумме: сортировка результатов по общей сумме потраченных денег.

Задание 10
Функции, реализуемые в задаче:

Категоризация отелей: для каждого отеля определяется его категория в зависимости от средней стоимости номера:

«Дешевый»: средняя стоимость менее 175 долларов.

«Средний»: средняя стоимость от 175 до 300 долларов.

«Дорогой»: средняя стоимость более 300 долларов.

Анализ предпочтений клиентов: для каждого клиента определяется его предпочтение в отелях:

Если клиент бронировал хотя бы один дорогой отель, его предпочтение — дорогой.

Если клиент не бронировал дорогие отели, но есть хотя бы один средний, его предпочтение — средний.

Если клиент не бронировал дорогие и средние отели, но есть дешевые, его предпочтение — дешевый.

Вывод информации: для каждого клиента нужно вывести:

ID_customer: уникальный идентификатор клиента.

name: имя клиента.

preferred_hotel_type: предпочитаемый тип отеля.

visited_hotels: список уникальных отелей, которые посетил клиент, объединенный через запятую.

Сортировка результатов: результаты должны быть отсортированы по предпочитаемому типу отеля:

Сначала клиенты, предпочитающие дешевые отели.

Затем средние.

В конце дорогие.

Описание SQL-запроса:

Категоризация отелей: использование конструкции CASE для категоризации отелей в зависимости от средней стоимости.

Анализ предпочтений клиентов: для каждого клиента используется агрегация, чтобы определить, какие категории отелей он посещал.

Вывод информации: для каждого клиента применяется функция GROUP_CONCAT для объединения уникальных отелей, которые он посещал.

Сортировка: сортировка результатов по предпочитаемому типу отеля с использованием ORDER BY.

Задание 11
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения подчиненных сотрудников: необходимо рекурсивно извлечь всех сотрудников, которые подчиняются Ивану Иванову (с EmployeeID = 1), а также их подчиненных и подчиненных подчиненных с использованием RECURSIVE в SQL.

Информация о сотрудниках: для каждого сотрудника нужно вывести:

EmployeeID: идентификатор сотрудника.

Name: имя сотрудника.

ManagerID: идентификатор менеджера.

Department: название отдела.

Role: название роли.

Проекты (если есть), конкатенированные через запятую. Если нет проектов — NULL.

Задачи, конкатенированные через запятую. Если нет задач — NULL.

Сортировка: результаты должны быть отсортированы по имени сотрудника.

Описание SQL-запроса:

Рекурсивный CTE (WITH RECURSIVE Subordinates AS):

Базовый запрос извлекает сотрудников, которые подчиняются Ивану Иванову, то есть у которых ManagerID = 1.

Рекурсивный запрос извлекает подчиненных для каждого из сотрудников и продолжает этот процесс для их подчиненных.

Подзапросы для проектов и задач:

Для каждого сотрудника извлекается список проектов и задач с использованием GROUP_CONCAT для объединения значений через запятую.

Основной запрос:

Извлекаются данные о сотрудниках, включая информацию о проектах и задачах.

Сортировка: результаты сортируются по имени сотрудника с использованием ORDER BY s.Name.

Задание 12
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения всех подчиненных сотрудников и их подчиненных: используя WITH RECURSIVE, извлекаются все подчиненные сотрудники, начиная с тех, кто подчиняется Ивану Иванову (с EmployeeID = 1), и далее для их подчиненных.

Подзапросы для проектов и задач:

Извлекается список проектов и задач для каждого сотрудника с использованием GROUP_CONCAT.

Подсчитывается количество задач для каждого сотрудника с использованием COUNT.

Подсчет количества прямых подчиненных для каждого сотрудника:

Используется подзапрос для подсчета сотрудников, у которых ManagerID = EmployeeID данного сотрудника.

Основной запрос:

Извлекаются данные о сотрудниках, их проектах, задачах, а также количество задач и подчиненных.

Сортировка: результаты сортируются по имени сотрудника с помощью ORDER BY s.Name.

Задание 13
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения всех подчиненных сотрудников: с использованием WITH RECURSIVE извлекаются все подчиненные сотрудники, начиная с менеджеров, и затем их подчиненные и подчиненные подчиненных.

Подзапросы для проектов и задач:

Для каждого сотрудника извлекается список проектов с использованием GROUP_CONCAT.

Для каждого сотрудника извлекается список задач с использованием GROUP_CONCAT.

Подсчет общего количества подчиненных для каждого менеджера:

Подсчитывается количество подчиненных сотрудников для каждого менеджера, включая всех подчиненных их подчиненных, с использованием подзапроса для подсчета сотрудников в Subordinates, у которых ManagerID = m.EmployeeID.

Фильтрация: фильтруются только те сотрудники, у которых количество подчиненных больше 0 с помощью HAVING TotalSubordinates > 0.

Основной запрос:

Извлекается информация о менеджерах, их подчиненных, связанных проектах и задачах.

Сортировка: результаты сортируются по имени менеджера с использованием ORDER BY m.Name.
