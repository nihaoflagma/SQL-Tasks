SQL-Tasks
В этом проекте представлены решения различных SQL-задач, которые охватывают основы работы с базами данных, включая создание таблиц, их наполнение и манипуляцию данными. Задания были решены с использованием языка SQL и охватывают четыре основные базы данных: транспортные средства, автомобильные гонки, бронирование отелей и структура организации.

В процессе работы были решены 13 задач, каждая из которых направлена на улучшение навыков работы с SQL. Примеры запросов включают фильтрацию, сортировку, агрегацию, использование объединений (UNION), подзапросов и рекурсивных запросов.

Базы данных
Мы использовали следующие базы данных для выполнения задач:

Транспортные средства — данные о различных транспортных средствах (автомобили, мотоциклы, велосипеды).

Автомобильные гонки — информация о гонках, автомобилях и их результатах.

Бронирование отелей — данные о бронированиях, клиентах и отелях.

Структура организации — данные о сотрудниках, менеджерах, проектах и задачах.

Каждая из этих баз данных сопровождается скриптами для создания и заполнения таблиц тестовыми данными, что позволяет ускорить решение задач.

Структура заданий
Задание 1
Функции:

Фильтрация данных: отбор мотоциклов по мощности, стоимости и типу.

Сортировка: результаты сортируются по мощности мотоциклов в убывающем порядке.

Структура запроса:

Фильтрация данных с использованием WHERE.

Сортировка с использованием ORDER BY.

Задание 2
Функции:

Фильтрация данных по нескольким критериям для автомобилей, мотоциклов и велосипедов.

Использование UNION для объединения данных из разных категорий транспортных средств.

Сортировка результатов по мощности с учетом велосипедов (с мощностью NULL).

Структура запроса:

Фильтрация для каждого типа транспортного средства.

Объединение данных с помощью UNION ALL.

Сортировка с использованием ORDER BY.

Задание 3
Функции:

Группировка по классу автомобилей и вычисление средней позиции с использованием агрегатной функции AVG.

Фильтрация автомобилей с минимальной средней позицией.

Сортировка результатов по средней позиции в порядке возрастания.

Структура запроса:

Группировка по классам автомобилей.

Использование HAVING для фильтрации по минимальной средней позиции.

Задание 4
Функции:

Вычисление средней позиции для каждого автомобиля.

Поиск автомобиля с наименьшей средней позицией среди всех.

Если несколько автомобилей имеют одинаковую минимальную позицию, выбор по алфавиту.

Структура запроса:

Извлечение данных о всех автомобилях и вычисление их средней позиции.

Использование MIN для нахождения минимальной средней позиции.

Задание 5
Функции, реализуемые в задаче:

Вычисление средней позиции для каждого класса автомобилей: для каждого класса автомобилей необходимо вычислить среднюю позицию с использованием агрегатной функции AVG.

Поиск классов с наименьшей средней позицией: нужно найти классы с наименьшей средней позицией среди всех классов с использованием агрегатной функции MIN.

Поиск автомобилей в этих классах: для каждого класса с минимальной средней позицией необходимо найти автомобили и вывести информацию о каждом:

Имя автомобиля.

Средняя позиция автомобиля.

Количество гонок, в которых автомобиль участвовал.

Страна производства класса автомобиля.

Вывод общего количества гонок для выбранных классов: для всех автомобилей, принадлежащих классам с наименьшей средней позицией, подсчитать общее количество гонок с использованием функции COUNT.

Обработка одинаковых минимальных позиций: если несколько классов имеют одинаковую минимальную позицию, нужно отобразить все эти классы.

Структура запроса:

Извлечь данные о всех автомобилях, вычислить среднюю позицию для каждого класса.

Использовать агрегатную функцию MIN для нахождения минимальной средней позиции.

Вывести информацию о каждом автомобиле в этих классах.

Посчитать количество гонок для автомобилей, относящихся к выбранным классам.

Отобразить все классы с одинаковыми минимальными позициями.

Задание 6
Функции, реализуемые в задаче:

Вычисление средней позиции автомобилей по классу: для каждого класса автомобилей необходимо вычислить среднюю позицию с помощью функции AVG.

Выбор автомобилей с лучшей средней позицией: нужно выбрать автомобили с средней позицией ниже средней по классу. Это реализуется с использованием подзапроса для получения средней позиции для каждого класса и сравнения с позициями автомобилей.

Фильтрация классов с минимум двумя автомобилями: исключаются классы, в которых участвует только один автомобиль.

Вывод информации об автомобилях: для выбранных автомобилей из классов с более чем одним автомобилем вывести:

Имя автомобиля.

Класс автомобиля.

Среднюю позицию автомобиля.

Количество гонок, в которых участвовал автомобиль.

Страну производства класса автомобиля.

Сортировка: результат сортируется по классу, затем по средней позиции в порядке возрастания.

Структура запроса:

Вычисление средней позиции по классу для каждого автомобиля.

Фильтрация автомобилей с лучшими позициями, которые меньше средней по классу.

Группировка автомобилей по классам, исключение классов с одним автомобилем.

Вывод информации о каждом выбранном автомобиле.

Сортировка по классу и средней позиции.

Задание 7
Функции, реализуемые в задаче:

Вычисление средней позиции автомобилей: для каждого автомобиля вычисляется его средняя позиция с использованием функции AVG.

Определение автомобилей с низкой средней позицией: фильтрация автомобилей с позицией больше 3.0.

Группировка автомобилей по классу: автомобили с низкой средней позицией группируются по классу, чтобы выявить классы с наибольшим количеством таких автомобилей.

Подсчет количества автомобилей с низкой средней позицией для каждого класса: для каждого класса считается количество автомобилей, у которых средняя позиция больше 3.0.

Общее количество гонок для каждого класса: подсчитывается общее количество гонок, в которых участвовали автомобили данного класса.

Вывод информации: для каждого автомобиля из классов с наибольшим количеством автомобилей с низкой средней позицией выводится:

Имя автомобиля.

Класс автомобиля.

Среднюю позицию.

Количество гонок.

Страну производства класса.

Общее количество гонок для класса.

Сортировка: результат сортируется по количеству автомобилей с низкой средней позицией в порядке убывания.

Структура запроса:

Для каждого автомобиля вычисляется его средняя позиция.

Фильтрация автомобилей с позицией больше 3.0.

Группировка автомобилей по классам.

Подсчет общего числа гонок для каждого класса.

Вывод информации об автомобиле и классе.

Сортировка по количеству автомобилей с низкой средней позицией.

Задание 8
Функции, реализуемые в задаче:

Группировка по клиентам: необходимо сгруппировать все бронирования по каждому клиенту, чтобы подсчитать количество бронирований.

Подсчет количества бронирований: для каждого клиента подсчитывается, сколько раз он бронировал номера, с условием, что количество бронирований должно быть больше двух.

Фильтрация по количеству бронирований: отбираются только те клиенты, у которых количество бронирований больше двух и которые бронировали номера в разных отелях.

Вывод списка отелей: для каждого клиента выводится список отелей, в которых он бронировал номера. Для этого используется функция GROUP_CONCAT для объединения всех названий отелей в одну строку через запятую.

Подсчет средней длительности пребывания: для каждого клиента вычисляется средняя длительность пребывания по всем его бронированиям с помощью функции AVG.

Сортировка результатов: результаты должны быть отсортированы по количеству бронирований в порядке убывания.

Описание SQL-запроса:

Группировка бронирований по клиенту: данные бронирований группируются по ClientID.

Подсчет количества бронирований и фильтрация: используется условие "больше двух бронирований" для каждого клиента.

Вывод списка отелей: с помощью функции GROUP_CONCAT объединяются все названия отелей для каждого клиента.

Подсчет средней длительности пребывания: используется функция AVG для вычисления средней длительности пребывания.

Сортировка результатов: сортировка выполняется по количеству бронирований в порядке убывания.

Задание 9
Функции, реализуемые в задаче:

Группировка данных по клиентам: нужно сгруппировать все бронирования по каждому клиенту.

Подсчет количества бронирований и уникальных отелей: для каждого клиента подсчитывается количество бронирований и уникальных отелей, в которых они забронировали номера.

Фильтрация клиентов по количеству бронирований: отбираются клиенты, которые сделали более двух бронирований и забронировали номера в разных отелях.

Подсчет общей потраченной суммы: для каждого клиента вычисляется общая сумма, потраченная на бронирования.

Фильтрация по сумме потраченных денег: отбираются только те клиенты, которые потратили более 500 долларов.

Объединение данных: объединяются клиенты, которые удовлетворяют обоим условиям.

Сортировка по общей сумме: результаты сортируются по общей сумме, потраченной клиентами, в порядке возрастания.

Описание SQL-запроса:

Группировка по клиенту: работа с таблицами Clients, Reservations, и Hotels для подсчета бронирований и уникальных отелей.

Подсчет бронирований и уникальных отелей: используется условие на количество бронирований и уникальных отелей для каждого клиента.

Фильтрация по количеству и сумме: клиенты, которые забронировали более двух отелей и потратили больше 500 долларов, отбираются с помощью условий.

Объединение данных: объединение информации из нескольких запросов.

Сортировка по сумме: сортировка результатов по общей сумме потраченных денег.

Задание 10
Функции, реализуемые в задаче:

Категоризация отелей: для каждого отеля определяется его категория в зависимости от средней стоимости номера:

«Дешевый»: средняя стоимость менее 175 долларов.

«Средний»: средняя стоимость от 175 до 300 долларов.

«Дорогой»: средняя стоимость более 300 долларов.

Анализ предпочтений клиентов: для каждого клиента определяется его предпочтение в отелях:

Если клиент бронировал хотя бы один дорогой отель, его предпочтение — дорогой.

Если клиент не бронировал дорогие отели, но есть хотя бы один средний, его предпочтение — средний.

Если клиент не бронировал дорогие и средние отели, но есть дешевые, его предпочтение — дешевый.

Вывод информации: для каждого клиента нужно вывести:

ID_customer: уникальный идентификатор клиента.

name: имя клиента.

preferred_hotel_type: предпочитаемый тип отеля.

visited_hotels: список уникальных отелей, которые посетил клиент, объединенный через запятую.

Сортировка результатов: результаты должны быть отсортированы по предпочитаемому типу отеля:

Сначала клиенты, предпочитающие дешевые отели.

Затем средние.

В конце дорогие.

Описание SQL-запроса:

Категоризация отелей: использование конструкции CASE для категоризации отелей в зависимости от средней стоимости.

Анализ предпочтений клиентов: для каждого клиента используется агрегация, чтобы определить, какие категории отелей он посещал.

Вывод информации: для каждого клиента применяется функция GROUP_CONCAT для объединения уникальных отелей, которые он посещал.

Сортировка: сортировка результатов по предпочитаемому типу отеля с использованием ORDER BY.

Задание 11
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения подчиненных сотрудников: необходимо рекурсивно извлечь всех сотрудников, которые подчиняются Ивану Иванову (с EmployeeID = 1), а также их подчиненных и подчиненных подчиненных с использованием RECURSIVE в SQL.

Информация о сотрудниках: для каждого сотрудника нужно вывести:

EmployeeID: идентификатор сотрудника.

Name: имя сотрудника.

ManagerID: идентификатор менеджера.

Department: название отдела.

Role: название роли.

Проекты (если есть), конкатенированные через запятую. Если нет проектов — NULL.

Задачи, конкатенированные через запятую. Если нет задач — NULL.

Сортировка: результаты должны быть отсортированы по имени сотрудника.

Описание SQL-запроса:

Рекурсивный CTE (WITH RECURSIVE Subordinates AS):

Базовый запрос извлекает сотрудников, которые подчиняются Ивану Иванову, то есть у которых ManagerID = 1.

Рекурсивный запрос извлекает подчиненных для каждого из сотрудников и продолжает этот процесс для их подчиненных.

Подзапросы для проектов и задач:

Для каждого сотрудника извлекается список проектов и задач с использованием GROUP_CONCAT для объединения значений через запятую.

Основной запрос:

Извлекаются данные о сотрудниках, включая информацию о проектах и задачах.

Сортировка: результаты сортируются по имени сотрудника с использованием ORDER BY s.Name.

Задание 12
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения всех подчиненных сотрудников и их подчиненных: используя WITH RECURSIVE, извлекаются все подчиненные сотрудники, начиная с тех, кто подчиняется Ивану Иванову (с EmployeeID = 1), и далее для их подчиненных.

Подзапросы для проектов и задач:

Извлекается список проектов и задач для каждого сотрудника с использованием GROUP_CONCAT.

Подсчитывается количество задач для каждого сотрудника с использованием COUNT.

Подсчет количества прямых подчиненных для каждого сотрудника:

Используется подзапрос для подсчета сотрудников, у которых ManagerID = EmployeeID данного сотрудника.

Основной запрос:

Извлекаются данные о сотрудниках, их проектах, задачах, а также количество задач и подчиненных.

Сортировка: результаты сортируются по имени сотрудника с помощью ORDER BY s.Name.

Задание 13
Функции, реализуемые в задаче:

Рекурсивный запрос для извлечения всех подчиненных сотрудников: с использованием WITH RECURSIVE извлекаются все подчиненные сотрудники, начиная с менеджеров, и затем их подчиненные и подчиненные подчиненных.

Подзапросы для проектов и задач:

Для каждого сотрудника извлекается список проектов с использованием GROUP_CONCAT.

Для каждого сотрудника извлекается список задач с использованием GROUP_CONCAT.

Подсчет общего количества подчиненных для каждого менеджера:

Подсчитывается количество подчиненных сотрудников для каждого менеджера, включая всех подчиненных их подчиненных, с использованием подзапроса для подсчета сотрудников в Subordinates, у которых ManagerID = m.EmployeeID.

Фильтрация: фильтруются только те сотрудники, у которых количество подчиненных больше 0 с помощью HAVING TotalSubordinates > 0.

Основной запрос:

Извлекается информация о менеджерах, их подчиненных, связанных проектах и задачах.

Сортировка: результаты сортируются по имени менеджера с использованием ORDER BY m.Name.
